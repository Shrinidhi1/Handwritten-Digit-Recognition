# -*- coding: utf-8 -*-
"""KNN(HWDR).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iqhQzbvOZjKiRgsEJCdfCuDccK8M68zh
"""

import numpy as np
import pandas as pd
import math 
from tensorflow import keras
import matplotlib.pyplot as plt
from matplotlib import style
style.use('ggplot')

(X_train, y_train) , (X_test, y_test) = keras.datasets.mnist.load_data()

X_train = X_train / 255
X_test = X_test / 255
X_train = X_train[:16000]
y_train = y_train[:16000]
X_test = X_test[:4000]
y_test = y_test[:4000]

print("First element of X_train is :")
X_train[0]

print("First element of Y_train is :")
y_train[0]

print ('The shape of X is: ' + str(X_train.shape))
print ('The shape of y is: ' + str(y_train.shape))

X_test = X_test.reshape(-1,28,28,1)
X_test.shape

def drawImg(sample):               
    img=sample.reshape((28,28))    
    plt.imshow(img,cmap='gray')
    plt.show()

i=0
while i<5:
  drawImg(X_train[i])
  print(y_train[i])
  i+=1

def euclidean_distance(x1,x2):
    return np.sqrt(np.sum((x1-x2)**2))

def knn(X,Y,query_point,k=5 ):
    vals=[]
    m=X_train.shape[0]
    
    for i in range(m):
        d=euclidean_distance(query_point,X[i])
        vals.append((d,Y[i])) 
            
    vals=sorted(vals)
    #print(vals)
    #Nearest/First k points
    vals=vals[:k]
    
    vals=np.array(vals)
    #print(vals)
    new_vals=np.unique(vals[:,1],return_counts=True)
    index=new_vals[1].argmax()
    pred=new_vals[0][index]
    
    return pred

def drawImg(sample):               
    img=sample.reshape((28,28))    
    plt.imshow(img,cmap='gray')
    plt.show()
    
drawImg(X_train[3])
print(y_train[3])

def calculate_accuracy(X_test, Y_test, X_train, Y_train, k=5):
    
    predictions = []
    
    for test_point in X_test:
        pred_label = knn(X_train, Y_train, test_point)
        predictions.append(pred_label)
    predictions = np.array(predictions).astype(int)
    accuracy = 0
    for i in predictions:
      if(predictions[i] == Y_test[i]):
        accuracy += 1
    accuracy = accuracy / Y_test.shape[0]
    return accuracy

accuracy=calculate_accuracy(X_test,y_test,X_train,y_train,5)

print(accuracy)